<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LLL&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.liulongblog.top/"/>
  <updated>2018-08-09T15:04:16.468Z</updated>
  <id>http://www.liulongblog.top/</id>
  
  <author>
    <name>Liu Long Long</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring aop</title>
    <link href="http://www.liulongblog.top/2018/08/10/spring-aop/"/>
    <id>http://www.liulongblog.top/2018/08/10/spring-aop/</id>
    <published>2018-08-10T14:15:16.000Z</published>
    <updated>2018-08-09T15:04:16.468Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-aop概述"><a href="#1-aop概述" class="headerlink" title="1. aop概述"></a>1. aop概述</h3><p>AOP，即Aspect Oriented Programming（面向切面编程），它是对面向对象编程的补充和完善，而oop适合定义横向的关系，aop适合定向横向的关系，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。<br>~~~~使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><h3 id="2-aop核心概念"><a href="#2-aop核心概念" class="headerlink" title="2. aop核心概念"></a>2. aop核心概念</h3><p>(1). 横切关注点<br>对哪些方法进行拦截，拦截后怎么处理，这些关注点成为横切关注点。<br>(2). 切面（aspect）<br>一般修饰一个类，该类是对物体特征的抽象，切面是横切关注点的抽象<br>(3). 连接点(Joinpoint)<br>被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器<br>(4). 切入点(pointCut)<br>对连接点进行拦截的定义<br>(5)通知，也称为增强（Advice），分为@Before，@After，@Around<br>@AfterRuturningAdvice，@AfterThrowingAdvice<br><img src="http://pcxs1rsya.bkt.clouddn.com/aop.png" alt=""></p><h3 id="3-实现简单的aop例子"><a href="#3-实现简单的aop例子" class="headerlink" title="3. 实现简单的aop例子"></a>3. 实现简单的aop例子</h3><p>@aspect 定义切面<br>@pointcut 定义切点<br>@before 标注Before Advice定义所在的方法<br>@afterreturning 标注After Returning Advice定义所在的方法<br>@afterthrowing 标注After Throwing Advice定义所在的方法<br>@after 标注 After(Finally) Advice定义所在的方法<br>@around 标注Around Advice定义所在的方法<br>execution：<br>  Spring AOP仅支持方法执行类型的Joinpoint 所以execution将会是我们用的最多的标志符，用它来帮我们匹配拥有指定方法前面的Joinpoint。匹配规则如下：<br>execution(modifiers-pattern? return-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern)</p><p>modifiers-pattern 修饰符 比如public private这种（可以指定可以不指定）<br>return-type-pattern 返回值类型（必须指定）<br>declaring-type-pattern 类型（可以是含包名的全路径类型 可以指定可以不指定）<br>name-pattern 方法名（必须指定）<br>param-pattern 参数类型（必须指定）<br>方法的返回类型 方法名及参数部分的匹配模式是必须指定的 其他部分可以省略。<br>我们还可以在表达式中使用两种通配符：<em>和..<br>  第一：</em>可以用于任何部分的匹配模式中，匹配相邻的多个字符，即一个Work 。如果放在了方法参数的位置标示参数是任何类型的。<br>例如：execution(<em> </em>(String))<br>  第二：..通配符可以在两个位置使用 一个是declaring-type-pattern的位置，一个是在方法参数匹配模式的位置。<br>如果是放在了方法类型的位置，可以指定多个层次的类型声明。例如：<br>execution(void cn.spring.<em>.doSomething(</em>)) 指定到cn.spring下的所有类型。<br>如果是放在了方法参数的匹配位置，则表示该方法可以有0到多个参数。例如：<br>execution(void *.doSomething(..))<br>业务类代码**<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.ctj.service;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class BusinessService &#123;</span><br><span class="line"></span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;Business Code&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>切面类定义：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.ctj.aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line">    @Pointcut(&quot;execution(* com.ctj.service.*.*(..))&quot;)</span><br><span class="line">    public void pointcutName()&#123;&#125;</span><br><span class="line">    @Before(&quot;pointcutName()&quot;)</span><br><span class="line">    public void performance()&#123;</span><br><span class="line">        System.out.println(&quot;Spring AOP&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>spring-aop.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</span><br><span class="line"></span><br><span class="line">    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd&quot;&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;logAspect&quot; class=&quot;com.ctj.aspect.LogAspect&quot;&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>参考来源：<br><a href="https://www.cnblogs.com/programmer1/p/7994031.html" target="_blank" rel="noopener">spring aop注解形式</a></p>]]></content>
    
    <summary type="html">
    
      spring aop
    
    </summary>
    
      <category term="框架" scheme="http://www.liulongblog.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="spring框架" scheme="http://www.liulongblog.top/tags/spring%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>mybatis中分页插件的使用</title>
    <link href="http://www.liulongblog.top/2018/08/09/pageHelper/"/>
    <id>http://www.liulongblog.top/2018/08/09/pageHelper/</id>
    <published>2018-08-09T14:15:16.000Z</published>
    <updated>2018-08-09T15:06:33.472Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-pageHelper应用场景"><a href="#1-pageHelper应用场景" class="headerlink" title="1.pageHelper应用场景"></a>1.pageHelper应用场景</h3><p>单表查询结果需要分页处理时，不支持多边联合查询，本文实在springboot项目中使用的</p><h3 id="2-使用步骤"><a href="#2-使用步骤" class="headerlink" title="2.使用步骤"></a>2.使用步骤</h3><p>(1). maven项目中引入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 分页插件 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>(2). application.yml中进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pagehelper分页插件</span><br><span class="line">pagehelper:</span><br><span class="line">    helperDialect: mysql</span><br><span class="line">    reasonable: true</span><br><span class="line">    supportMethodsArguments: true</span><br><span class="line">    params: count=countSql</span><br></pre></td></tr></table></figure></p><p>(3). controller中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//以查询所有为例，代码如下</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;/listAll&quot;)</span><br><span class="line">public String listAll(@RequestParam(required = false,defaultValue = &quot;1&quot;,value = &quot;currentPage&quot;)Integer currentPage,@RequestParam(required = false,value = &quot;pageSize&quot;)Integer pageSize,</span><br><span class="line">          Model model) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">PageHelper.startPage(currentPage, pageSize);//必须紧跟查询方法</span><br><span class="line">List&lt;TestTableVO&gt; lists = tableService.listAll();</span><br><span class="line">PageInfo&lt;TestTableVO&gt; pageInfo= new PageInfo&lt;&gt;(lists);</span><br><span class="line">model.addAttribute(&quot;pageInfo&quot;, pageInfo);</span><br><span class="line">model.addAttribute(&quot;userList&quot;, lists);</span><br><span class="line">    return &quot;userList&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      pageHelpert开源分页插件的使用
    
    </summary>
    
      <category term="JavaWeb" scheme="http://www.liulongblog.top/categories/JavaWeb/"/>
    
    
      <category term="javaweb" scheme="http://www.liulongblog.top/tags/javaweb/"/>
    
  </entry>
  
  <entry>
    <title>HashMap和Hashtable的区别</title>
    <link href="http://www.liulongblog.top/2018/08/01/hashtanle/"/>
    <id>http://www.liulongblog.top/2018/08/01/hashtanle/</id>
    <published>2018-08-01T14:15:16.000Z</published>
    <updated>2018-08-03T12:54:44.573Z</updated>
    
    <content type="html"><![CDATA[<p>##HashMap和Hashtable的区别<br><img src="http://img.zcool.cn/community/0166fc554bf523000001bf72e68af5.jpg@1280w_1l_2o_100sh.jpg" alt="Example"><br>1.<strong>继承的父类不同</strong></p><hr><p>  HashMap继承自AbstractMap类，而Hashtable继承自Dictoonary类，不过它们都实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口</p><hr><a id="more"></a><p>2.<strong>键值空值支持</strong></p><hr><p>Hashtable既不支持Null key也不支持Null value<br>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p><hr><p>3.<strong>线程安全</strong></p><hr><p><em>Hashtable是线程按安全的，HashMap不是线程安全的</em>使用HashMap时就必须要自己增加同步处理，虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p><hr><p>4.<strong>遍历方式不同</strong></p><hr><hr><p>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p><hr><p>4.<strong>初始化容量大小不同</strong></p><hr><p>Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</p><hr>]]></content>
    
    <summary type="html">
    
      HashMap和Hashtable的区别
    
    </summary>
    
      <category term="默认分类" scheme="http://www.liulongblog.top/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="java基础" scheme="http://www.liulongblog.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>对servlet的一点儿认识</title>
    <link href="http://www.liulongblog.top/2018/08/01/servlet/"/>
    <id>http://www.liulongblog.top/2018/08/01/servlet/</id>
    <published>2018-08-01T14:15:16.000Z</published>
    <updated>2018-08-09T13:30:09.478Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>[TOC]</p><h2 id="1-servlet简介"><a href="#1-servlet简介" class="headerlink" title="1.servlet简介"></a>1.servlet简介</h2><p>servlet是运行在服务端的java程序，用来处理客户端（浏览器）的请求，并对请求做出响应。</p><h2 id="2-servlet生命周期"><a href="#2-servlet生命周期" class="headerlink" title="2.servlet生命周期"></a>2.servlet生命周期</h2><p>servlet默认是单例模式，也就是整个生命周期只会被初始化一次<br>(1). Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。<br>(2). 装载并创建该Servlet的一个实例对象。<br>(3). 调用Servlet实例对象的init()方法。<br>(4). 创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。<br>(5). WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 </p><h2 id="3-servlet开发步骤"><a href="#3-servlet开发步骤" class="headerlink" title="3.servlet开发步骤"></a>3.servlet开发步骤</h2><p>(1). 新建一个web程序，Servlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。<br>HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。<br>(2). 新建一个servlet，继承自HttpServlet，重写doGet(),doPost()方法<br>(3). web.xml配置servlet映射。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;com.ucl.controller.ServletDemo1&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/servlet/ServletDemo1&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>(4). 浏览器输入<a href="http://localhost:8080/springMVC/servlet/demo1,即可" target="_blank" rel="noopener">http://localhost:8080/springMVC/servlet/demo1,即可</a></p><h2 id="4-servlet存在的线程安全问题。"><a href="#4-servlet存在的线程安全问题。" class="headerlink" title="4.servlet存在的线程安全问题。"></a>4.servlet存在的线程安全问题。</h2><p>针对Servlet的线程安全问题，Sun公司是提供有解决方案的：让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了SingleThreadModel接口，那么Servlet引擎将以单线程模式来调用其service方法。<br>　　查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量，在Java中，把没有定义任何方法和常量的接口称之为标记接口，经常看到的一个最典型的标记接口就是”Serializable”，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了”Serializable”接口的类的对象就可以被序列化，还有一个”Cloneable”接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了”Cloneable”接口，那么对象就可以被克隆了。</p><p>　　让Servlet实现了SingleThreadModel接口，只要在Servlet类的定义中增加实现SingleThreadModel接口的声明即可。<br>　　对于实现了SingleThreadModel接口的Servlet，Servlet引擎仍然支持对该Servlet的多线程并发访问，其采用的方式是产生多个Servlet实例对象，并发的每个线程分别调用一个独立的Servlet实例对象。<br>　　实现SingleThreadModel接口并不能真正解决Servlet的线程安全问题，因为Servlet引擎会创建多个Servlet实例对象，而真正意义上解决多线程安全问题是指一个Servlet实例对象被多个线程同时调用的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）。<br>  参考文章：<br>  <strong><a href="https://www.cnblogs.com/xdp-gacl/p/3760336.html" target="_blank" rel="noopener">javaweb学习总结(五)——Servlet开发(一)</a></strong></p>]]></content>
    
    <summary type="html">
    
      servlet的内容回顾
    
    </summary>
    
      <category term="JavaWeb" scheme="http://www.liulongblog.top/categories/JavaWeb/"/>
    
    
      <category term="javaweb" scheme="http://www.liulongblog.top/tags/javaweb/"/>
    
  </entry>
  
  <entry>
    <title>历史的变迁</title>
    <link href="http://www.liulongblog.top/2018/07/02/Hair/"/>
    <id>http://www.liulongblog.top/2018/07/02/Hair/</id>
    <published>2018-07-02T14:15:16.000Z</published>
    <updated>2018-08-09T13:32:11.614Z</updated>
    
    <content type="html"><![CDATA[<p><strong>20180804上班一个月</strong></p><p>时间|发际线|发量</p><p>—|:–:|—:</p><p>20180804|8|8</p><h6 id="评分标准：满分10分，6分及格、"><a href="#评分标准：满分10分，6分及格、" class="headerlink" title="评分标准：满分10分，6分及格、"></a>评分标准：满分10分，6分及格、</h6><p><img src="http://pcxs1rsya.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720180805000146.jpg" alt="还行"></p><hr><p><img src="http://pcxs1rsya.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720180805000153.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      码农头发由多到少
    
    </summary>
    
      <category term="个人" scheme="http://www.liulongblog.top/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="生活" scheme="http://www.liulongblog.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
