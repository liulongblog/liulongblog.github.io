<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring aop]]></title>
    <url>%2F2018%2F08%2F10%2Fspring-aop%2F</url>
    <content type="text"><![CDATA[[TOC] 1. aop概述AOP，即Aspect Oriented Programming（面向切面编程），它是对面向对象编程的补充和完善，而oop适合定义横向的关系，aop适合定向横向的关系，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。~~~~使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 2. aop核心概念(1). 横切关注点对哪些方法进行拦截，拦截后怎么处理，这些关注点成为横切关注点。(2). 切面（aspect）一般修饰一个类，该类是对物体特征的抽象，切面是横切关注点的抽象(3). 连接点(Joinpoint)被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器(4). 切入点(pointCut)对连接点进行拦截的定义(5)通知，也称为增强（Advice），分为@Before，@After，@Around@AfterRuturningAdvice，@AfterThrowingAdvice 3. 实现简单的aop例子@aspect 定义切面@pointcut 定义切点@before 标注Before Advice定义所在的方法@afterreturning 标注After Returning Advice定义所在的方法@afterthrowing 标注After Throwing Advice定义所在的方法@after 标注 After(Finally) Advice定义所在的方法@around 标注Around Advice定义所在的方法execution： Spring AOP仅支持方法执行类型的Joinpoint 所以execution将会是我们用的最多的标志符，用它来帮我们匹配拥有指定方法前面的Joinpoint。匹配规则如下：execution(modifiers-pattern? return-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern) modifiers-pattern 修饰符 比如public private这种（可以指定可以不指定）return-type-pattern 返回值类型（必须指定）declaring-type-pattern 类型（可以是含包名的全路径类型 可以指定可以不指定）name-pattern 方法名（必须指定）param-pattern 参数类型（必须指定）方法的返回类型 方法名及参数部分的匹配模式是必须指定的 其他部分可以省略。我们还可以在表达式中使用两种通配符：和.. 第一：可以用于任何部分的匹配模式中，匹配相邻的多个字符，即一个Work 。如果放在了方法参数的位置标示参数是任何类型的。例如：execution( (String)) 第二：..通配符可以在两个位置使用 一个是declaring-type-pattern的位置，一个是在方法参数匹配模式的位置。如果是放在了方法类型的位置，可以指定多个层次的类型声明。例如：execution(void cn.spring..doSomething()) 指定到cn.spring下的所有类型。如果是放在了方法参数的匹配位置，则表示该方法可以有0到多个参数。例如：execution(void *.doSomething(..))业务类代码**12345678910package com.ctj.service;import org.springframework.stereotype.Service;@Servicepublic class BusinessService &#123; public void say()&#123; System.out.println(&quot;Business Code&quot;); &#125;&#125; 切面类定义：1234567891011121314package com.ctj.aspect;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;@Aspectpublic class LogAspect &#123; @Pointcut(&quot;execution(* com.ctj.service.*.*(..))&quot;) public void pointcutName()&#123;&#125; @Before(&quot;pointcutName()&quot;) public void performance()&#123; System.out.println(&quot;Spring AOP&quot;); &#125;&#125; spring-aop.xml1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd&quot;&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; &lt;bean id=&quot;logAspect&quot; class=&quot;com.ctj.aspect.LogAspect&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; 参考来源：spring aop注解形式]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis入门]]></title>
    <url>%2F2018%2F08%2F10%2FRedis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.Redis简介Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 2.基本数据类型(1). string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个键最大能存储512MB。1234redis 127.0.0.1:6379&gt; SET name &quot;redis.net.cn&quot;OKredis 127.0.0.1:6379&gt; GET name&quot;redis.net.cn&quot; (2). Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。12345678910redis 127.0.0.1:6379&gt; HMSET user:1 username redis.net.cn password redis.net.cn points 200OKredis 127.0.0.1:6379&gt; HGETALL user:11) &quot;username&quot;2) &quot;redis.net.cn&quot;3) &quot;password&quot;4) &quot;redis.net.cn&quot;5) &quot;points&quot;6) &quot;200&quot;redis 127.0.0.1:6379&gt; (3). List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。 实例123456789101112redis 127.0.0.1:6379&gt; lpush redis.net.cn redis(integer) 1redis 127.0.0.1:6379&gt; lpush redis.net.cn mongodb(integer) 2redis 127.0.0.1:6379&gt; lpush redis.net.cn rabitmq(integer) 3redis 127.0.0.1:6379&gt; lrange redis.net.cn 0 101) &quot;rabitmq&quot;2) &quot;mongodb&quot;3) &quot;redis&quot;redis 127.0.0.1:6379&gt;列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 (4). Set（集合）Redis的Set是string类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 sadd 命令添加一个string元素到,key对应的set集合中，成功返回1,如果元素以及在集合中返回0,key对应的set不存在返回错误。 sadd key member实例12345678910111213redis 127.0.0.1:6379&gt; sadd redis.net.cn redis(integer) 1redis 127.0.0.1:6379&gt; sadd redis.net.cn mongodb(integer) 1redis 127.0.0.1:6379&gt; sadd redis.net.cn rabitmq(integer) 1redis 127.0.0.1:6379&gt; sadd redis.net.cn rabitmq(integer) 0redis 127.0.0.1:6379&gt; smembers redis.net.cn 1) &quot;rabitmq&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; 注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 zset的成员是唯一的,但分数(score)却可以重复。 zadd 命令添加元素到集合，元素在集合中存在则更新对应score zadd key score member实例12345678910111213redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 redis(integer) 1redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 mongodb(integer) 1redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq(integer) 1redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq(integer) 0redis 127.0.0.1:6379&gt; ZRANGEBYSCORE redis.net.cn 0 1000 1) &quot;redis&quot;2) &quot;mongodb&quot;3) &quot;rabitmq&quot; 3. java使用Redis连接到 redis 服务12345678910import redis.clients.jedis.Jedis;public class RedisJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;); System.out.println(&quot;Connection to server sucessfully&quot;); //查看服务是否运行 System.out.println(&quot;Server is running: &quot;+jedis.ping()); &#125;&#125; 编译以上 Java 程序，确保驱动包的路径是正确的。1234$javac RedisJava.java$java RedisJavaConnection to server sucessfullyServer is running: PONG Redis Java String ExampleRedis Java String(字符串) 实例123456789101112import redis.clients.jedis.Jedis;public class RedisStringJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;); System.out.println(&quot;Connection to server sucessfully&quot;); //设置 redis 字符串数据 jedis.set(&quot;w3ckey&quot;, &quot;Redis tutorial&quot;); // 获取存储的数据并输出 System.out.println(&quot;Stored string in redis:: &quot;+ jedis.get(&quot;w3ckey&quot;)); &#125;&#125; 编译以上程序。12345678910111213141516171819202122$javac RedisStringJava.java$java RedisStringJavaConnection to server sucessfullyStored string in redis:: Redis tutorialRedis Java List(列表) 实例import redis.clients.jedis.Jedis;public class RedisListJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;); System.out.println(&quot;Connection to server sucessfully&quot;); //存储数据到列表中 jedis.lpush(&quot;tutorial-list&quot;, &quot;Redis&quot;); jedis.lpush(&quot;tutorial-list&quot;, &quot;Mongodb&quot;); jedis.lpush(&quot;tutorial-list&quot;, &quot;Mysql&quot;); // 获取存储的数据并输出 List&lt;String&gt; list = jedis.lrange(&quot;tutorial-list&quot;, 0 ,5); for(int i=0; i&lt;list.size(); i++) &#123; System.out.println(&quot;Stored string in redis:: &quot;+list.get(i)); &#125; &#125;&#125; 编译以上程序。123456$javac RedisListJava.java$java RedisListJavaConnection to server sucessfullyStored string in redis:: RedisStored string in redis:: MongodbStored string in redis:: Mysql Redis Java Keys 实例1234567891011121314import redis.clients.jedis.Jedis;public class RedisKeyJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;); System.out.println(&quot;Connection to server sucessfully&quot;); // 获取数据并输出 List&lt;String&gt; list = jedis.keys(&quot;*&quot;); for(int i=0; i&lt;list.size(); i++) &#123; System.out.println(&quot;List of stored keys:: &quot;+list.get(i)); &#125; &#125;&#125; 编译以上程序。12345$javac RedisKeyJava.java$java RedisKeyJavaConnection to server sucessfullyList of stored keys:: tutorial-nameList of stored keys:: tutorial-list]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis中分页插件的使用]]></title>
    <url>%2F2018%2F08%2F09%2FpageHelper%2F</url>
    <content type="text"><![CDATA[[TOC] 1.pageHelper应用场景单表查询结果需要分页处理时，不支持多边联合查询，本文实在springboot项目中使用的 2.使用步骤(1). maven项目中引入依赖123456&lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; (2). application.yml中进行配置123456#pagehelper分页插件pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql (3). controller中使用12345678910111213//以查询所有为例，代码如下@RequestMapping(&quot;/listAll&quot;) public String listAll(@RequestParam(required = false,defaultValue = &quot;1&quot;,value = &quot;currentPage&quot;)Integer currentPage,@RequestParam(required = false,value = &quot;pageSize&quot;)Integer pageSize, Model model) throws Exception&#123; PageHelper.startPage(currentPage, pageSize);//必须紧跟查询方法 List&lt;TestTableVO&gt; lists = tableService.listAll(); PageInfo&lt;TestTableVO&gt; pageInfo= new PageInfo&lt;&gt;(lists); model.addAttribute(&quot;pageInfo&quot;, pageInfo); model.addAttribute(&quot;userList&quot;, lists); return &quot;userList&quot;; &#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap和Hashtable的区别]]></title>
    <url>%2F2018%2F08%2F01%2Fhashtanle%2F</url>
    <content type="text"><![CDATA[##HashMap和Hashtable的区别1.继承的父类不同 HashMap继承自AbstractMap类，而Hashtable继承自Dictoonary类，不过它们都实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口 2.键值空值支持 Hashtable既不支持Null key也不支持Null valueHashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 3.线程安全 Hashtable是线程按安全的，HashMap不是线程安全的使用HashMap时就必须要自己增加同步处理，虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。 4.遍历方式不同 Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 4.初始化容量大小不同 Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对servlet的一点儿认识]]></title>
    <url>%2F2018%2F08%2F01%2Fservlet%2F</url>
    <content type="text"><![CDATA[[TOC] 1.servlet简介servlet是运行在服务端的java程序，用来处理客户端（浏览器）的请求，并对请求做出响应。 2.servlet生命周期servlet默认是单例模式，也就是整个生命周期只会被初始化一次(1). Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。(2). 装载并创建该Servlet的一个实例对象。(3). 调用Servlet实例对象的init()方法。(4). 创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。(5). WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 3.servlet开发步骤(1). 新建一个web程序，Servlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。(2). 新建一个servlet，继承自HttpServlet，重写doGet(),doPost()方法(3). web.xml配置servlet映射。12345678 &lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ucl.controller.ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ServletDemo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; (4). 浏览器输入http://localhost:8080/springMVC/servlet/demo1,即可 4.servlet存在的线程安全问题。针对Servlet的线程安全问题，Sun公司是提供有解决方案的：让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了SingleThreadModel接口，那么Servlet引擎将以单线程模式来调用其service方法。 查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量，在Java中，把没有定义任何方法和常量的接口称之为标记接口，经常看到的一个最典型的标记接口就是”Serializable”，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了”Serializable”接口的类的对象就可以被序列化，还有一个”Cloneable”接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了”Cloneable”接口，那么对象就可以被克隆了。 让Servlet实现了SingleThreadModel接口，只要在Servlet类的定义中增加实现SingleThreadModel接口的声明即可。 对于实现了SingleThreadModel接口的Servlet，Servlet引擎仍然支持对该Servlet的多线程并发访问，其采用的方式是产生多个Servlet实例对象，并发的每个线程分别调用一个独立的Servlet实例对象。 实现SingleThreadModel接口并不能真正解决Servlet的线程安全问题，因为Servlet引擎会创建多个Servlet实例对象，而真正意义上解决多线程安全问题是指一个Servlet实例对象被多个线程同时调用的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）。 参考文章： javaweb学习总结(五)——Servlet开发(一)]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[历史的变迁]]></title>
    <url>%2F2018%2F07%2F02%2FHair%2F</url>
    <content type="text"><![CDATA[20180804上班一个月 时间|发际线|发量 —|:–:|—: 20180804|8|8 评分标准：满分10分，6分及格、]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
